"""
Optimized bank endpoints with async PostgreSQL and fast queries.
Uses composite indexes for location-based searches.
"""

import logging
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_, or_
from app.core.database import get_db
from app.core.cache import cached
from app.models.optimized_models import Banks, BanksIFSCS
from app.schemas import schemas
from app.core.auth import get_current_client

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/banks", tags=["Banks - Optimized"],
    dependencies=[Depends(get_current_client)])  # <---- PROTECT ALL ROUTES


@router.get("/")
@cached(key_prefix="all_banks", expire=600)  # Cache for 10 minutes
async def get_all_banks(db: AsyncSession = Depends(get_db)):
    """
    Get all banks with priority sorting (optimized).

    Performance: Uses composite index on (status, priority, bankName).
    """
    logger.info("Fetching all banks")

    # Uses ix_bank_status_priority composite index
    query = (
        select(Banks)
        .where(Banks.status == True)
        .order_by(Banks.priority.desc(), Banks.bankName)
    )

    result = await db.execute(query)
    banks = result.scalars().all()

    return {
        "success": True,
        "records": [
            {
                "id": bank.id,
                "bankName": bank.bankName,
                "status": bank.status,
                "priority": bank.priority,
                "bankImage": bank.bankImage,
                "stored_date": bank.stored_date.isoformat() if bank.stored_date else None,
            }
            for bank in banks
        ],
    }


@router.post("/branches")
@cached(key_prefix="bank_branches", expire=300)
async def get_bank_branches(
    bank: schemas.BankBranchIn,
    skip: int = Query(0, ge=0),
    limit: int = Query(500, ge=1, le=2000),
    db: AsyncSession = Depends(get_db),
):
    """
    Get branches for a bank (optimized with index).

    Performance: Uses index on bankName.
    """
    logger.info(f"Fetching branches for bank: {bank.bankName}")

    # Uses ix_ifsc_bank index
    query = (
        select(BanksIFSCS)
        .where(BanksIFSCS.bankName == bank.bankName)
        .order_by(BanksIFSCS.branch)
        .offset(skip)
        .limit(limit)
    )

    result = await db.execute(query)
    branches = result.scalars().all()

    return {
        "success": True,
        "count": len(branches),
        "records": [
            {
                "id": b.id,
                "bankName": b.bankName,
                "branch": b.branch,
                "ifsc": b.ifsc,
                "city1": b.city1,
                "city2": b.city2,
                "state": b.state,
                "address": b.address,
                "phone": b.phone,
            }
            for b in branches
        ],
    }


@router.get("/search/branches")
async def search_branches(
    bank_name: Optional[str] = None,
    ifsc: Optional[str] = None,
    city: Optional[str] = None,
    state: Optional[str] = None,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=500),
    db: AsyncSession = Depends(get_db),
):
    """
    Search branches with multiple filters (optimized).

    Performance:
    - Uses ix_ifsc_bank_city for bank+city queries
    - Uses ix_ifsc_location for state+city queries
    - Uses ix_ifsc_code for IFSC lookups
    """
    logger.info(f"Searching branches - bank:{bank_name}, city:{city}, state:{state}, ifsc:{ifsc}")

    query = select(BanksIFSCS)

    # Build optimized query with appropriate indexes
    filters = []

    if bank_name:
        filters.append(BanksIFSCS.bankName == bank_name)

    if ifsc:
        # Exact match on unique index (fastest)
        filters.append(BanksIFSCS.ifsc == ifsc.upper())

    if city:
        # Uses composite indexes
        filters.append(
            or_(
                BanksIFSCS.city1.ilike(f"%{city}%"),
                BanksIFSCS.city2.ilike(f"%{city}%"),
            )
        )

    if state:
        filters.append(BanksIFSCS.state.ilike(f"%{state}%"))

    if filters:
        query = query.where(and_(*filters))

    # Order by relevance
    if bank_name and city:
        # Uses ix_ifsc_bank_city composite index
        query = query.order_by(BanksIFSCS.bankName, BanksIFSCS.city1)
    else:
        query = query.order_by(BanksIFSCS.bankName, BanksIFSCS.branch)

    query = query.offset(skip).limit(limit)

    result = await db.execute(query)
    branches = result.scalars().all()

    return {
        "success": True,
        "count": len(branches),
        "filters": {
            "bank_name": bank_name,
            "ifsc": ifsc,
            "city": city,
            "state": state,
        },
        "results": [
            {
                "id": b.id,
                "bankName": b.bankName,
                "branch": b.branch,
                "ifsc": b.ifsc,
                "city": b.city1 or b.city2,
                "state": b.state,
                "address": b.address,
                "phone": b.phone,
            }
            for b in branches
        ],
    }


@router.get("/ifsc/{ifsc_code}")
@cached(key_prefix="ifsc_lookup", expire=3600)  # Cache for 1 hour
async def get_by_ifsc(
    ifsc_code: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Get branch by IFSC code (fastest - unique index lookup).

    Performance: O(1) lookup using unique index.
    """
    logger.info(f"IFSC lookup: {ifsc_code}")

    # Uses unique index on IFSC (fastest possible query)
    query = select(BanksIFSCS).where(BanksIFSCS.ifsc == ifsc_code.upper())

    result = await db.execute(query)
    branch = result.scalar_one_or_none()

    if not branch:
        raise HTTPException(status_code=404, detail=f"IFSC code {ifsc_code} not found")

    return {
        "success": True,
        "data": {
            "id": branch.id,
            "bankName": branch.bankName,
            "branch": branch.branch,
            "ifsc": branch.ifsc,
            "city": branch.city1 or branch.city2,
            "state": branch.state,
            "address": branch.address,
            "phone": branch.phone,
            "stdcode": branch.stdcode,
        },
    }


@router.get("/stats")
@cached(key_prefix="bank_stats", expire=600)
async def get_bank_stats(db: AsyncSession = Depends(get_db)):
    """
    Get bank statistics (optimized aggregations).

    Performance: Uses COUNT with indexes.
    """
    # Total banks
    banks_query = select(func.count(Banks.id)).where(Banks.status == True)
    banks_result = await db.execute(banks_query)
    total_banks = banks_result.scalar()

    # Total branches
    branches_query = select(func.count(BanksIFSCS.id))
    branches_result = await db.execute(branches_query)
    total_branches = branches_result.scalar()

    # Branches by bank (top 10)
    top_banks_query = (
        select(BanksIFSCS.bankName, func.count(BanksIFSCS.id).label("branch_count"))
        .group_by(BanksIFSCS.bankName)
        .order_by(func.count(BanksIFSCS.id).desc())
        .limit(10)
    )
    top_banks_result = await db.execute(top_banks_query)
    top_banks = top_banks_result.all()

    return {
        "total_banks": total_banks,
        "total_branches": total_branches,
        "top_banks_by_branches": [
            {"bank": bank, "branches": count} for bank, count in top_banks
        ],
    }
