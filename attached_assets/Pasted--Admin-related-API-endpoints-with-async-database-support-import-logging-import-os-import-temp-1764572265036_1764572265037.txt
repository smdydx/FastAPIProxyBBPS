"""Admin-related API endpoints with async database support."""

import logging
import os
import tempfile
import pandas as pd
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, text
from typing import Optional, List, Dict, Any

from app.core.database import get_db
import app.models.optimized_models  as models
#import models
from app.core.settings import settings

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/admin", tags=["Admin"])


@router.post("/upload-billers/")
async def upload_billers(
    file: UploadFile = File(...),
    db: AsyncSession = Depends(get_db),
):
    """
    Upload biller data from an Excel file into the database.

    Expects an Excel file with columns: blr_id, blr_name, blr_category_name, blr_coverage
    """
    logger.info(f"Uploading billers from file: {file.filename}")

    try:
        # Read Excel file
        contents = await file.read()

        # Save temporarily
        with tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx') as tmp:
            tmp.write(contents)
            tmp_path = tmp.name

        # Read with pandas
        df = pd.read_excel(tmp_path)

        # Validate required columns
        required_columns = ["blr_id", "blr_name", "blr_category_name", "blr_coverage"]
        missing_columns = [col for col in required_columns if col not in df.columns]
        if missing_columns:
            raise HTTPException(
                status_code=400,
                detail=f"Missing required columns: {', '.join(missing_columns)}"
            )

        # Insert data using async operations
        count = 0
        for _, row in df.iterrows():
            biller = models.Biller(
                blr_id=row["blr_id"],
                blr_name=row["blr_name"],
                blr_category_name=row["blr_category_name"],
                blr_coverage=row["blr_coverage"],
            )
            db.add(biller)  # Add to session (merge not needed with upserts)
            count += 1

        await db.commit()
        logger.info(f"Successfully uploaded {count} billers")

        # Clean up temp file
        os.unlink(tmp_path)

        return {
            "success": True,
            "message": f"{count} biller records inserted successfully.",
        }

    except Exception as e:
        logger.error(f"Error uploading billers: {e}", exc_info=True)
        await db.rollback()
        raise HTTPException(status_code=400, detail=str(e))


@router.get("/seed-data/")
async def seed_data(db: AsyncSession = Depends(get_db)):
    """
    Seed data from backup/temporary tables to main tables.
    Note: This endpoint requires source tables to exist.
    """
    logger.info("Seeding data from backup tables")

    try:
        # This is a placeholder - implement based on your actual data migration needs
        # Example: Copy from BanksIFSCSCopied to BanksIFSCS

        # For now, just return a message
        return {
            "success": True,
            "message": "Data seeding completed. Implement specific migration logic as needed.",
        }

    except Exception as e:
        logger.error(f"Error seeding data: {e}", exc_info=True)
        await db.rollback()
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/health")
def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "service": settings.APP_NAME,
        "version": "1.0.0",
    }


@router.get("/stats")
async def get_stats(db: AsyncSession = Depends(get_db)):
    """Get database statistics."""
    try:
        # Use async select queries with func.count()
        billers_query = select(func.count()).select_from(models.Biller)
        banks_query = select(func.count()).select_from(models.Banks)
        branches_query = select(func.count()).select_from(models.BanksIFSCS)
        mdm_query = select(func.count()).select_from(models.BillerMDM)
        transactions_query = select(func.count()).select_from(models.BBPSTransactions)

        # Execute queries asynchronously
        billers_count = (await db.execute(billers_query)).scalar()
        banks_count = (await db.execute(banks_query)).scalar()
        branches_count = (await db.execute(branches_query)).scalar()
        mdm_count = (await db.execute(mdm_query)).scalar()
        transactions_count = (await db.execute(transactions_query)).scalar()

        stats = {
            "billers_count": billers_count,
            "banks_count": banks_count,
            "branches_count": branches_count,
            "mdm_count": mdm_count,
            "transactions_count": transactions_count,
        }
        return {"success": True, "stats": stats}
    except Exception as e:
        logger.error(f"Error fetching stats: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/categories/distinct")
async def get_distinct_categories(
    db: AsyncSession = Depends(get_db),
    include_count: bool = False
):
    """
    Get all distinct categories from billers table.

    Args:
        include_count: If True, includes count of billers per category

    Returns:
        List of distinct categories with optional counts
    """
    try:
        if include_count:
            # Get distinct categories with counts
            query = (
                select(
                    models.Biller.blr_category_name,
                    func.count(models.Biller.blr_id).label("biller_count")
                )
                .group_by(models.Biller.blr_category_name)
                .order_by(models.Biller.blr_category_name)
            )
            result = await db.execute(query)
            categories = result.all()

            return {
                "success": True,
                "total_categories": len(categories),
                "categories": [
                    {
                        "category_name": cat[0],
                        "biller_count": cat[1]
                    }
                    for cat in categories
                ]
            }
        else:
            # Get distinct categories only
            query = (
                select(models.Biller.blr_category_name)
                .distinct()
                .order_by(models.Biller.blr_category_name)
            )
            result = await db.execute(query)
            categories = result.scalars().all()

            return {
                "success": True,
                "total_categories": len(categories),
                "categories": categories
            }

    except Exception as e:
        logger.error(f"Error fetching distinct categories: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/categories/procedures/simple")
async def get_categories_simple_procedure(db: AsyncSession = Depends(get_db)):
    """
    Call PostgreSQL stored procedure: get_distinct_categories()

    Returns:
        Simple list of distinct category names
    """
    try:
        # Call the stored procedure
        query = text("SELECT * FROM get_distinct_categories()")
        result = await db.execute(query)
        categories = [row[0] for row in result.fetchall()]

        return {
            "success": True,
            "total_categories": len(categories),
            "categories": categories,
            "source": "PostgreSQL stored procedure: get_distinct_categories()"
        }

    except Exception as e:
        logger.error(f"Error calling get_distinct_categories procedure: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Error calling stored procedure. Make sure it's installed: {str(e)}"
        )


@router.get("/categories/procedures/with-counts")
async def get_categories_with_counts_procedure(db: AsyncSession = Depends(get_db)):
    """
    Call PostgreSQL stored procedure: get_categories_with_counts()

    Returns:
        Categories with biller counts
    """
    try:
        # Call the stored procedure
        query = text("SELECT * FROM get_categories_with_counts()")
        result = await db.execute(query)
        rows = result.fetchall()

        categories: List[Dict[str, Any]] = [
            {
                "category_name": row[0],
                "biller_count": row[1]
            }
            for row in rows
        ]

        return {
            "success": True,
            "total_categories": len(categories),
            "categories": categories,
            "source": "PostgreSQL stored procedure: get_categories_with_counts()"
        }

    except Exception as e:
        logger.error(f"Error calling get_categories_with_counts procedure: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Error calling stored procedure. Make sure it's installed: {str(e)}"
        )


@router.get("/categories/procedures/detailed")
async def get_categories_detailed_procedure(db: AsyncSession = Depends(get_db)):
    """
    Call PostgreSQL stored procedure: get_categories_detailed()

    Returns:
        Categories with active/inactive breakdown

    Note: Requires billers_v2 table with is_active field
    """
    try:
        # Call the stored procedure
        query = text("SELECT * FROM get_categories_detailed()")
        result = await db.execute(query)
        rows = result.fetchall()

        categories: List[Dict[str, Any]] = [
            {
                "category_name": row[0],
                "total_billers": row[1],
                "active_billers": row[2],
                "inactive_billers": row[3]
            }
            for row in rows
        ]

        return {
            "success": True,
            "total_categories": len(categories),
            "categories": categories,
            "source": "PostgreSQL stored procedure: get_categories_detailed()"
        }

    except Exception as e:
        logger.error(f"Error calling get_categories_detailed procedure: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Error calling stored procedure. Make sure it's installed: {str(e)}"
        )






















# """Admin-related API endpoints with async database support."""

# import logging
# import os
# import tempfile
# import pandas as pd
# from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
# from sqlalchemy.ext.asyncio import AsyncSession
# from sqlalchemy import select, func
# from typing import Optional

# from app.core.database import get_db
# import app.models.optimized_models  as models
# #import models
# from app.core.settings import settings

# logger = logging.getLogger(__name__)

# router = APIRouter(prefix="/admin", tags=["Admin"])


# @router.post("/upload-billers/")
# async def upload_billers(
#     file: UploadFile = File(...),
#     db: AsyncSession = Depends(get_db),
# ):
#     """
#     Upload biller data from an Excel file into the database.

#     Expects an Excel file with columns: blr_id, blr_name, blr_category_name, blr_coverage
#     """
#     logger.info(f"Uploading billers from file: {file.filename}")

#     try:
#         # Read Excel file
#         contents = await file.read()

#         # Save temporarily
#         with tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx') as tmp:
#             tmp.write(contents)
#             tmp_path = tmp.name

#         # Read with pandas
#         df = pd.read_excel(tmp_path)

#         # Validate required columns
#         required_columns = ["blr_id", "blr_name","blr_alias_name", "blr_category_name", "blr_coverage"]
#         missing_columns = [col for col in required_columns if col not in df.columns]
#         if missing_columns:
#             raise HTTPException(
#                 status_code=400,
#                 detail=f"Missing required columns: {', '.join(missing_columns)}"
#             )

#         # Insert data using async operations
#         count = 0
#         for _, row in df.iterrows():
#             biller = models.Biller(
#                 blr_id=row["blr_id"],
#                 blr_name=row["blr_name"],
#                 blr_alias_name=row["blr_alias_name"],
#                 blr_category_name=row["blr_category_name"],
#                 blr_coverage=row["blr_coverage"],
#             )
#             db.add(biller)  # Add to session (merge not needed with upserts)
#             count += 1

#         await db.commit()
#         logger.info(f"Successfully uploaded {count} billers")

#         # Clean up temp file
#         os.unlink(tmp_path)

#         return {
#             "success": True,
#             "message": f"{count} biller records inserted successfully.",
#         }

#     except Exception as e:
#         logger.error(f"Error uploading billers: {e}", exc_info=True)
#         await db.rollback()
#         raise HTTPException(status_code=400, detail=str(e))


# @router.get("/seed-data/")
# async def seed_data(db: AsyncSession = Depends(get_db)):
#     """
#     Seed data from backup/temporary tables to main tables.
#     Note: This endpoint requires source tables to exist.
#     """
#     logger.info("Seeding data from backup tables")

#     try:
#         # This is a placeholder - implement based on your actual data migration needs
#         # Example: Copy from BanksIFSCSCopied to BanksIFSCS

#         # For now, just return a message
#         return {
#             "success": True,
#             "message": "Data seeding completed. Implement specific migration logic as needed.",
#         }

#     except Exception as e:
#         logger.error(f"Error seeding data: {e}", exc_info=True)
#         await db.rollback()
#         raise HTTPException(status_code=500, detail=str(e))


# @router.get("/health")
# def health_check():
#     """Health check endpoint."""
#     return {
#         "status": "healthy",
#         "service": settings.APP_NAME,
#         "version": "1.0.0",
#     }


# @router.get("/stats")
# async def get_stats(db: AsyncSession = Depends(get_db)):
#     """Get database statistics."""
#     try:
#         # Use async select queries with func.count()
#         billers_query = select(func.count()).select_from(models.Biller)
#         banks_query = select(func.count()).select_from(models.Banks)
#         branches_query = select(func.count()).select_from(models.BanksIFSCS)
#         mdm_query = select(func.count()).select_from(models.BillerMDM)
#         transactions_query = select(func.count()).select_from(models.BBPSTransactions)

#         # Execute queries asynchronously
#         billers_count = (await db.execute(billers_query)).scalar()
#         banks_count = (await db.execute(banks_query)).scalar()
#         branches_count = (await db.execute(branches_query)).scalar()
#         mdm_count = (await db.execute(mdm_query)).scalar()
#         transactions_count = (await db.execute(transactions_query)).scalar()

#         stats = {
#             "billers_count": billers_count,
#             "banks_count": banks_count,
#             "branches_count": branches_count,
#             "mdm_count": mdm_count,
#             "transactions_count": transactions_count,
#         }
#         return {"success": True, "stats": stats}
#     except Exception as e:
#         logger.error(f"Error fetching stats: {e}", exc_info=True)
#         raise HTTPException(status_code=500, detail=str(e))



























# """Admin-related API endpoints."""

# import logging
# import pandas as pd
# from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
# from sqlalchemy.orm import Session
# from typing import Optional

# from app.core.database import get_db
# import app.models.optimized_models   as models
# from app.core.settings import settings

# logger = logging.getLogger(__name__)

# router = APIRouter(prefix="/admin", tags=["Admin"])


# @router.post("/upload-billers/")
# async def upload_billers(
#     file: UploadFile = File(...),
#     db: Session = Depends(get_db),
# ):
#     """
#     Upload biller data from an Excel file into the database.

#     Expects an Excel file with columns: blr_id, blr_name, blr_category_name, blr_coverage
#     """
#     logger.info(f"Uploading billers from file: {file.filename}")

#     try:
#         # Read Excel file
#         contents = await file.read()

#         # Save temporarily
#         import tempfile
#         with tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx') as tmp:
#             tmp.write(contents)
#             tmp_path = tmp.name

#         # Read with pandas
#         df = pd.read_excel(tmp_path)

#         # Validate required columns
#         required_columns = ["blr_id", "blr_name","blr_alias_name", "blr_category_name", "blr_coverage"]
#         missing_columns = [col for col in required_columns if col not in df.columns]
#         if missing_columns:
#             raise HTTPException(
#                 status_code=400,
#                 detail=f"Missing required columns: {', '.join(missing_columns)}"
#             )

#         # Insert data
#         count = 0
#         for _, row in df.iterrows():
#             biller = models.Biller(
#                 blr_id=row["blr_id"],
#                 blr_name=row["blr_name"],
#                 blr_alias_name=row["blr_alias_name"],
#                 blr_category_name=row["blr_category_name"],
#                 blr_coverage=row["blr_coverage"],
#             )
#             db.merge(biller)  # Merge to avoid duplicates
#             count += 1

#         db.commit()
#         logger.info(f"Successfully uploaded {count} billers")

#         # Clean up temp file
#         import os
#         os.unlink(tmp_path)

#         return {
#             "success": True,
#             "message": f"{count} biller records inserted successfully.",
#         }

#     except Exception as e:
#         logger.error(f"Error uploading billers: {e}", exc_info=True)
#         db.rollback()
#         raise HTTPException(status_code=400, detail=str(e))


# @router.get("/seed-data/")
# def seed_data(db: Session = Depends(get_db)):
#     """
#     Seed data from backup/temporary tables to main tables.
#     Note: This endpoint requires source tables to exist.
#     """
#     logger.info("Seeding data from backup tables")

#     try:
#         # This is a placeholder - implement based on your actual data migration needs
#         # Example: Copy from BanksIFSCSCopied to BanksIFSCS

#         # For now, just return a message
#         return {
#             "success": True,
#             "message": "Data seeding completed. Implement specific migration logic as needed.",
#         }

#     except Exception as e:
#         logger.error(f"Error seeding data: {e}", exc_info=True)
#         db.rollback()
#         raise HTTPException(status_code=500, detail=str(e))


# @router.get("/health")
# def health_check():
#     """Health check endpoint."""
#     return {
#         "status": "healthy",
#         "service": settings.APP_NAME,
#         "version": "1.0.0",
#     }


# @router.get("/stats")
# def get_stats(db: Session = Depends(get_db)):
#     """Get database statistics."""
#     try:
#         stats = {
#             "billers_count": db.query(models.Biller).count(),
#             "banks_count": db.query(models.Banks).count(),
#             "branches_count": db.query(models.BanksIFSCS).count(),
#             "mdm_count": db.query(models.BillerMDM).count(),
#             "transactions_count": db.query(models.BBPSTransactions).count(),
#         }
#         return {"success": True, "stats": stats}
#     except Exception as e:
#         logger.error(f"Error fetching stats: {e}", exc_info=True)
#         raise HTTPException(status_code=500, detail=str(e))
