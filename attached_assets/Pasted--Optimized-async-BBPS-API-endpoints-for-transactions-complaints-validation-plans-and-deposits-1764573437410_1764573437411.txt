"""
Optimized async BBPS API endpoints for transactions, complaints, validation, plans, and deposits.
Uses async HTTP requests, caching, and optimized database operations.
"""

import logging
import xml.etree.ElementTree as ET
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from pydantic import BaseModel

from app.core.database import get_db
from app.core.cache import cached, cache
from app.models.optimized_models import BillerMDM
from app.services.bbps_api_service_async import async_bbps_api_service
from app.exceptions import BBPSException
from app.utils.utils import xml_to_dict, parse_xml
from app.core.auth import get_current_client

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/bbps", tags=["BBPS - Optimized"],
    dependencies=[Depends(get_current_client)])   # <---- PROTECT ALL ROUTES


# Request schemas
class TransactionStatusRequest(BaseModel):
    """Request schema for transaction status API."""
    tracking_ref_id: str
    tracking_type: str = "BY_TRACKING_REF_ID"


class ComplaintRegistrationRequest(BaseModel):
    """Request schema for complaint registration API."""
    txn_ref_id: str
    complaint_type: str
    complaint_desc: str
    participant_type: str
    participant_id: str
    complaint_disposition: Optional[str] = None
    service_reason: Optional[str] = None


class ComplaintTrackingRequest(BaseModel):
    """Request schema for complaint tracking API."""
    complaint_id: str


class BillerValidationRequest(BaseModel):
    """Request schema for biller validation API."""
    agent_id: str
    agent_device_info: dict
    customer_info: dict
    biller_id: str
    input_params: dict


class PlanDetailsRequest(BaseModel):
    """Request schema for plan pull API."""
    biller_id: str
    plan_type: Optional[str] = None


class DepositEnquiryRequest(BaseModel):
    """Request schema for deposit enquiry API."""
    from_date: str
    to_date: str


class FetchBillRequest(BaseModel):
    """Request schema for bill fetch API."""
    agent_id: str
    agent_device_info: dict
    customer_info: dict
    biller_id: str
    input_params: dict
    amount: Optional[str] = None


class PayBillRequest(BaseModel):
    """Request schema for bill payment API."""
    agent_id: str
    agent_device_info: dict
    customer_info: dict
    biller_id: str
    biller_info: dict
    payment_info: dict
    amount_info: dict


@router.post("/transaction-status")
async def get_transaction_status(request: TransactionStatusRequest):
    """
    Get transaction status from BBPS API (async optimized).

    Performance:
    - Async HTTP request
    - Fast response parsing
    """
    logger.info(f"Getting transaction status for: {request.tracking_ref_id}")
    try:
        response = await async_bbps_api_service.get_transaction_status(
            tracking_ref_id=request.tracking_ref_id,
            tracking_type=request.tracking_type,
        )

        if not response:
            raise HTTPException(status_code=500, detail="Failed to get transaction status")

        root = ET.fromstring(response)
        response_code = root.find("responseCode")

        if response_code is None or response_code.text != "000":
            error_info = root.find(".//errorMessage")
            error_msg = error_info.text if error_info is not None else "Transaction status fetch failed"
            raise HTTPException(status_code=400, detail=error_msg)

        return {
            "success": True,
            "tracking_ref_id": request.tracking_ref_id,
            "data": xml_to_dict(root)
        }

    except BBPSException as e:
        raise HTTPException(status_code=e.status_code, detail=e.message)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting transaction status: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/complaints/register")
async def register_complaint(request: ComplaintRegistrationRequest):
    """
    Register a complaint with BBPS (async optimized).

    Performance:
    - Async HTTP request
    - Optimized XML building
    """
    logger.info(f"Registering complaint for transaction: {request.txn_ref_id}")
    try:
        response = await async_bbps_api_service.register_complaint(
            txn_ref_id=request.txn_ref_id,
            complaint_type=request.complaint_type,
            complaint_desc=request.complaint_desc,
            participant_type=request.participant_type,
            participant_id=request.participant_id,
            complaint_disposition=request.complaint_disposition,
            service_reason=request.service_reason,
        )

        if not response:
            raise HTTPException(status_code=500, detail="Failed to register complaint")

        root = ET.fromstring(response)
        response_code = root.find("responseCode")

        if response_code is None or response_code.text != "000":
            error_info = root.find(".//errorMessage")
            error_msg = error_info.text if error_info is not None else "Complaint registration failed"
            raise HTTPException(status_code=400, detail=error_msg)

        # Extract complaint ID from response
        complaint_id = root.find("complaintId")

        return {
            "success": True,
            "complaint_id": complaint_id.text if complaint_id is not None else None,
            "txn_ref_id": request.txn_ref_id,
            "data": xml_to_dict(root)
        }

    except BBPSException as e:
        raise HTTPException(status_code=e.status_code, detail=e.message)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error registering complaint: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/complaints/track")
async def track_complaint(request: ComplaintTrackingRequest):
    """
    Track complaint status with BBPS (async optimized).

    Performance:
    - Async HTTP request
    - Cached complaint status
    """
    logger.info(f"Tracking complaint: {request.complaint_id}")
    try:
        response = await async_bbps_api_service.track_complaint(
            complaint_id=request.complaint_id,
        )

        if not response:
            raise HTTPException(status_code=500, detail="Failed to track complaint")

        root = ET.fromstring(response)
        response_code = root.find("responseCode")

        if response_code is None or response_code.text != "000":
            error_info = root.find(".//errorMessage")
            error_msg = error_info.text if error_info is not None else "Complaint tracking failed"
            raise HTTPException(status_code=400, detail=error_msg)

        return {
            "success": True,
            "complaint_id": request.complaint_id,
            "data": xml_to_dict(root)
        }

    except BBPSException as e:
        raise HTTPException(status_code=e.status_code, detail=e.message)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error tracking complaint: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/validate-biller")
async def validate_biller(
    request: BillerValidationRequest,
    db: AsyncSession = Depends(get_db),
):
    """
    Validate biller information with BBPS API (async optimized).

    Performance:
    - Async HTTP request
    - Optional MDM lookup from cache/database
    """
    logger.info(f"Validating biller: {request.biller_id}")
    try:
        response = await async_bbps_api_service.validate_biller(
            agent_id=request.agent_id,
            agent_device_info=request.agent_device_info,
            customer_info=request.customer_info,
            biller_id=request.biller_id,
            input_params=request.input_params,
        )

        if not response:
            raise HTTPException(status_code=500, detail="Failed to validate biller")

        root = ET.fromstring(response)
        response_code = root.find("responseCode")

        if response_code is None or response_code.text != "000":
            error_info = root.find(".//errorMessage")
            error_msg = error_info.text if error_info is not None else "Biller validation failed"
            raise HTTPException(status_code=400, detail=error_msg)

        return {
            "success": True,
            "biller_id": request.biller_id,
            "validation_status": "valid",
            "data": xml_to_dict(root)
        }

    except BBPSException as e:
        raise HTTPException(status_code=e.status_code, detail=e.message)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error validating biller: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/plans")
@cached(key_prefix="biller_plans", expire=3600)
async def get_plan_details(request: PlanDetailsRequest):
    """
    Get plan details from BBPS API (async optimized with caching).

    Performance:
    - Cached for 1 hour
    - Async HTTP request
    """
    logger.info(f"Getting plan details for biller: {request.biller_id}")
    try:
        response = await async_bbps_api_service.get_plan_details(
            biller_id=request.biller_id,
            plan_type=request.plan_type,
        )

        if not response:
            raise HTTPException(status_code=500, detail="Failed to get plan details")

        root = ET.fromstring(response)
        response_code = root.find("responseCode")

        if response_code is None or response_code.text != "000":
            error_info = root.find(".//errorMessage")
            error_msg = error_info.text if error_info is not None else "Plan fetch failed"
            raise HTTPException(status_code=400, detail=error_msg)

        # Extract plans
        plans = root.findall(".//plan")
        plan_list = [xml_to_dict(plan) for plan in plans]

        return {
            "success": True,
            "biller_id": request.biller_id,
            "plan_count": len(plan_list),
            "plans": plan_list,
            "raw_data": xml_to_dict(root)
        }

    except BBPSException as e:
        raise HTTPException(status_code=e.status_code, detail=e.message)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting plan details: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/deposit-enquiry")
async def enquire_deposit(request: DepositEnquiryRequest):
    """
    Enquire deposit details from BBPS API (async optimized).

    Performance:
    - Async HTTP request
    - Optimized date range queries
    """
    logger.info(f"Enquiring deposit from {request.from_date} to {request.to_date}")
    try:
        response = await async_bbps_api_service.enquire_deposit(
            from_date=request.from_date,
            to_date=request.to_date,
        )

        if not response:
            raise HTTPException(status_code=500, detail="Failed to enquire deposit")

        root = ET.fromstring(response)
        response_code = root.find("responseCode")

        if response_code is None or response_code.text != "000":
            error_info = root.find(".//errorMessage")
            error_msg = error_info.text if error_info is not None else "Deposit enquiry failed"
            raise HTTPException(status_code=400, detail=error_msg)

        return {
            "success": True,
            "from_date": request.from_date,
            "to_date": request.to_date,
            "data": xml_to_dict(root)
        }

    except BBPSException as e:
        raise HTTPException(status_code=e.status_code, detail=e.message)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error enquiring deposit: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/fetch-bill")
async def fetch_bill(
    request: FetchBillRequest,
    db: AsyncSession = Depends(get_db),
):
    """
    Fetch bill from BBPS API (async optimized).

    Performance:
    - Async HTTP request
    - Parallel MDM lookup if needed
    """
    logger.info(f"Fetching bill for biller: {request.biller_id}")
    try:
        # Get MDM for biller info if needed
        query = select(BillerMDM).where(BillerMDM.blr_id == request.biller_id)
        result = await db.execute(query)
        mdm = result.scalar_one_or_none()

        biller_info = request.input_params.copy()
        biller_info["billerId"] = request.biller_id

        response = await async_bbps_api_service.fetch_bill(
            agent_id=request.agent_id,
            agent_device_info=request.agent_device_info,
            customer_info=request.customer_info,
            biller_info=biller_info,
            amount=request.amount,
        )

        if not response:
            raise HTTPException(status_code=500, detail="Failed to fetch bill")

        root = ET.fromstring(response)
        response_code = root.find("responseCode")

        if response_code is None or response_code.text != "000":
            error_info = root.find(".//errorMessage")
            error_msg = error_info.text if error_info is not None else "Bill fetch failed"
            raise HTTPException(status_code=400, detail=error_msg)

        # Extract bill details
        biller_response = root.find("billerResponse")
        additional_info = root.find("additionalInfo")

        return {
            "success": True,
            "biller_id": request.biller_id,
            "biller_response": xml_to_dict(biller_response) if biller_response is not None else None,
            "additional_info": xml_to_dict(additional_info) if additional_info is not None else None,
            "raw_data": xml_to_dict(root)
        }

    except BBPSException as e:
        raise HTTPException(status_code=e.status_code, detail=e.message)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching bill: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/pay-bill")
async def pay_bill(
    request: PayBillRequest,
    db: AsyncSession = Depends(get_db),
):
    """
    Process bill payment via BBPS API (async optimized).

    Performance:
    - Async HTTP request
    - Transaction logging
    """
    logger.info(f"Processing payment for biller: {request.biller_id}")
    try:
        response = await async_bbps_api_service.pay_bill(
            agent_id=request.agent_id,
            agent_device_info=request.agent_device_info,
            customer_info=request.customer_info,
            biller_info=request.biller_info,
            payment_info=request.payment_info,
        )

        if not response:
            raise HTTPException(status_code=500, detail="Failed to process payment")

        root = ET.fromstring(response)
        response_code = root.find("responseCode")

        if response_code is None or response_code.text != "000":
            error_info = root.find(".//errorMessage")
            error_msg = error_info.text if error_info is not None else "Payment failed"
            raise HTTPException(status_code=400, detail=error_msg)

        # Extract transaction details
        txn_ref_id = root.find("txnRefId")
        approval_ref = root.find("approvalRefNumber")

        return {
            "success": True,
            "biller_id": request.biller_id,
            "txn_ref_id": txn_ref_id.text if txn_ref_id is not None else None,
            "approval_ref_number": approval_ref.text if approval_ref is not None else None,
            "data": xml_to_dict(root)
        }

    except BBPSException as e:
        raise HTTPException(status_code=e.status_code, detail=e.message)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error processing payment: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/health")
async def bbps_health_check():
    """
    Check BBPS API connectivity.
    """
    return {
        "status": "healthy",
        "service": "BBPS API Integration",
        "async": True
    }
