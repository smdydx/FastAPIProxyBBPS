from fastapi import APIRouter, Depends, HTTPException
from fastapi.security import OAuth2PasswordRequestForm
from pydantic import BaseModel
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.core.database import get_db
from app.models.optimized_models import Users as BBPSClient
from app.core.security import verify_password, create_access_token
from app.core.auth import get_current_client
from app.core.security import hash_password
router = APIRouter(prefix="/auth", tags=["Auth"])

class ClientLogin(BaseModel):
    client_id: str
    client_password: str


class ClientRegister(BaseModel):
    client_id: str
    client_name: str
    client_company_name: str | None = None
    client_contact_no: str | None = None
    client_password: str
    client_address: str | None = None



# @router.post("/register")
# async def register_client(payload: ClientRegister, db: AsyncSession = Depends(get_db)):
#     # Check if client exists
#     stmt = select(BBPSClient).where(BBPSClient.client_id == payload.client_id)
#     result = await db.execute(stmt)
#     exists = result.scalar_one_or_none()

#     if exists:
#         raise HTTPException(status_code=400, detail="Client already registered")

#     hashed_pwd = hash_password(payload.client_password)

#     new_client = BBPSClient(
#         client_id=payload.client_id,
#         client_name=payload.client_name,
#         client_company_name=payload.client_company_name,
#         client_contact_no=payload.client_contact_no,
#         client_password=hashed_pwd,
#         client_address=payload.client_address,
#         is_online__aadharkyc_enabled="no",
#         is_online__pan_kyc_enabled="no",
#         is_fingerprint_enabled=False,
#         is_blocked=False
#     )

#     db.add(new_client)
#     await db.commit()
#     await db.refresh(new_client)

#     return {"message": "Client registered successfully"}



# @router.post("/client-token")
# async def client_token(payload: ClientLogin, db: AsyncSession = Depends(get_db)):
#     stmt = select(BBPSClient).where(BBPSClient.client_id == payload.client_id)
#     result = await db.execute(stmt)
#     client = result.scalar_one_or_none()

#     if not client:
#         raise HTTPException(status_code=401, detail="Invalid client_id")

#     if client.is_blocked:
#         raise HTTPException(status_code=403, detail="Client is blocked")

#     if not verify_password(payload.client_password, client.client_password):
#         raise HTTPException(status_code=401, detail="Invalid password")

#     token = create_access_token({
#         "client_id": client.client_id,
#         "client_name": client.client_name
#     })

#     return {"access_token": token, "token_type": "bearer"}


@router.post("/token")
async def oauth2_token(form_data: OAuth2PasswordRequestForm = Depends(), db: AsyncSession = Depends(get_db)):
    """OAuth2 compatible token endpoint to support Swagger `Authorize` flow.

    This accepts `username` and `password` as form fields and returns an access_token.
    """
    stmt = select(BBPSClient).where(BBPSClient.client_id == form_data.username)
    result = await db.execute(stmt)
    client = result.scalar_one_or_none()

    if not client:
        raise HTTPException(status_code=401, detail="Invalid client_id")

    if client.is_blocked:
        raise HTTPException(status_code=403, detail="Client is blocked")

    if not verify_password(form_data.password, client.client_password):
        raise HTTPException(status_code=401, detail="Invalid password")

    token = create_access_token({
        "client_id": client.client_id,
        "client_name": client.client_name
    })

    return {"access_token": token, "token_type": "bearer"}


@router.get("/validate-token")
async def validate_token(current=Depends(get_current_client)):
    return {"valid": True, "client": current}



@router.get("/secure/profile")
async def get_profile(current=Depends(get_current_client), db: AsyncSession = Depends(get_db)):
    stmt = select(BBPSClient).where(BBPSClient.client_id == current["client_id"])
    result = await db.execute(stmt)
    client = result.scalar_one()

    return {
        "client_id": client.client_id,
        "client_name": client.client_name,
        "company": client.client_company_name,
        "contact": client.client_contact_no
    }


# @router.post("/client-token")
# async def client_token(payload: ClientLogin, db: AsyncSession = Depends(get_db)):
#     stmt = select(BBPSClient).where(BBPSClient.client_id == payload.client_id)
#     result = await db.execute(stmt)
#     client = result.scalar_one_or_none()

#     if not client:
#         raise HTTPException(status_code=401, detail="Invalid client_id")

#     if client.is_blocked:
#         raise HTTPException(status_code=403, detail="Client is blocked")

#     if not verify_password(payload.client_password, client.client_password):
#         raise HTTPException(status_code=401, detail="Invalid password")

#     token = create_access_token({
#         "client_id": client.client_id,
#         "client_name": client.client_name
#     })

#     return {"access_token": token, "token_type": "bearer"}
