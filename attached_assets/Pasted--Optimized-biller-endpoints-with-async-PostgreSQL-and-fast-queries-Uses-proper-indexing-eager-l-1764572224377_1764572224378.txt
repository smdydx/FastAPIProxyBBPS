"""
Optimized biller endpoints with async PostgreSQL and fast queries.
Uses proper indexing, eager loading, and query optimization.
"""

import logging
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, or_
from sqlalchemy.orm import selectinload

from app.core.database import get_db
from app.core.cache import cached
from app.models.optimized_models import Biller, BillerMDM
from app.schemas import schemas
from app.exceptions import BillerNotFoundException
from app.core.auth import get_current_client
logger = logging.getLogger(__name__)

# router = APIRouter(prefix="/billers", tags=["Billers - Optimized"])
router=APIRouter(prefix="/billers",
    tags=["Billers - Optimized"],
    dependencies=[Depends(get_current_client)])  # <---- PROTECT ALL ROUTES


@router.get("/", response_model=List[dict])
@cached(key_prefix="all_billers", expire=300)  # Cache for 5 minutes
async def get_all_billers(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    db: AsyncSession = Depends(get_db),
):
    """
    Get all billers with pagination (optimized async query).

    Performance optimizations:
    - Uses limit/offset for pagination
    - Cached for 5 minutes
    - Index on blr_name for sorting
    """
    logger.info(f"Fetching billers (skip={skip}, limit={limit})")

    # Optimized query with ordering
    query = (
        select(Biller)
        .order_by(Biller.blr_category_name, Biller.blr_name)
        .offset(skip)
        .limit(limit)
    )

    result = await db.execute(query)
    billers = result.scalars().all()

    return [
        {
            "blr_id": b.blr_id,
            "blr_name": b.blr_name,
            "blr_category_name": b.blr_category_name,
            "blr_coverage": b.blr_coverage,
        }
        for b in billers
    ]


@router.get("/count")
@cached(key_prefix="billers_count", expire=600)  # Cache for 10 minutes
async def get_billers_count(
    category: Optional[str] = None,
    db: AsyncSession = Depends(get_db),
):
    """Get total count of billers (fast count query)."""
    query = select(func.count(Biller.blr_id))

    if category:
        query = query.where(Biller.blr_category_name == category)

    result = await db.execute(query)
    count = result.scalar()

    return {"count": count}


@router.post("/info")
async def get_biller_info(
    biller: schemas.GetBillerInfoInput,
    db: AsyncSession = Depends(get_db),
):
    """
    Get specific biller by ID (optimized with primary key lookup).

    Performance: O(1) lookup using primary key index.
    """
    logger.info(f"Fetching biller info for ID: {biller.billerid}")

    # Direct primary key lookup (fastest)
    query = select(Biller).where(Biller.blr_id == biller.billerid)
    result = await db.execute(query)
    biller_obj = result.scalar_one_or_none()

    if not biller_obj:
        raise HTTPException(status_code=404, detail=f"Biller {biller.billerid} not found")

    return {
        "blr_id": biller_obj.blr_id,
        "blr_name": biller_obj.blr_name,
        "blr_category_name": biller_obj.blr_category_name,
        "blr_coverage": biller_obj.blr_coverage,
    }


@router.get("/by-category/")
@cached(key_prefix="billers_by_category", expire=300)
async def get_billers_by_category(
    category: str,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    db: AsyncSession = Depends(get_db),
):
    """
    Get billers by category (optimized with index scan).

    Performance: Uses composite index on (category, name).
    """
    logger.info(f"Fetching billers for category: {category}")

    # Uses ix_biller_category_name composite index
    query = (
        select(Biller)
        .where(Biller.blr_category_name == category)
        .order_by(Biller.blr_name)
        .offset(skip)
        .limit(limit)
    )

    result = await db.execute(query)
    billers = result.scalars().all()

    return [
        {
            "blr_id": b.blr_id,
            "blr_name": b.blr_name,
            "blr_category_name": b.blr_category_name,
            "blr_coverage": b.blr_coverage,
        }
        for b in billers
    ]


@router.get("/categories/")
@cached(key_prefix="biller_categories", expire=600)  # Cache for 10 minutes
async def get_biller_categories(db: AsyncSession = Depends(get_db)):
    """
    Get all distinct categories (optimized distinct query).

    Performance: Uses index on blr_category_name.
    """
    logger.info("Fetching all biller categories")

    # Optimized distinct query
    query = select(Biller.blr_category_name).distinct().order_by(Biller.blr_category_name)

    result = await db.execute(query)
    categories = result.scalars().all()

    return list(categories)


@router.get("/search")
async def search_billers(
    q: str = Query(..., min_length=2, description="Search query"),
    category: Optional[str] = None,
    skip: int = Query(0, ge=0),
    limit: int = Query(50, ge=1, le=500),
    db: AsyncSession = Depends(get_db),
):
    """
    Search billers by name (optimized with ILIKE and index).

    Performance:
    - Uses index on blr_name for prefix searches
    - PostgreSQL ILIKE for case-insensitive search
    """
    logger.info(f"Searching billers with query: {q}")

    # Build optimized search query
    query = select(Biller)

    # Search in name (uses index for prefix match)
    query = query.where(
        or_(
            Biller.blr_name.ilike(f"{q}%"),  # Prefix match (can use index)
            Biller.blr_id.ilike(f"%{q}%"),
        )
    )

    # Optional category filter
    if category:
        query = query.where(Biller.blr_category_name == category)

    # Order and paginate
    query = query.order_by(Biller.blr_name).offset(skip).limit(limit)

    result = await db.execute(query)
    billers = result.scalars().all()

    return {
        "count": len(billers),
        "results": [
            {
                "blr_id": b.blr_id,
                "blr_name": b.blr_name,
                "blr_category_name": b.blr_category_name,
                "blr_coverage": b.blr_coverage,
            }
            for b in billers
        ],
    }


@router.get("/mdm/{biller_id}")
@cached(key_prefix="biller_mdm", expire=3600)  # Cache for 1 hour
async def get_biller_mdm(
    biller_id: str,
    db: AsyncSession = Depends(get_db),
):
    """
    Get biller MDM by ID (optimized with index lookup).

    Performance: Uses composite index on (blr_id, category).
    """
    logger.info(f"Fetching MDM for biller: {biller_id}")

    # Uses ix_mdm_biller_id index
    query = select(BillerMDM).where(BillerMDM.blr_id == biller_id)

    result = await db.execute(query)
    mdm = result.scalar_one_or_none()

    if not mdm:
        raise HTTPException(status_code=404, detail=f"MDM for biller {biller_id} not found")

    return {
        "blr_id": mdm.blr_id,
        "category": mdm.category,
        "mdm_xml": mdm.mdm_xml,
        "image_base64": mdm.image_base64,
        "created_at": mdm.created_at.isoformat() if mdm.created_at else None,
        "updated_at": mdm.updated_at.isoformat() if mdm.updated_at else None,
    }


@router.get("/stats")
@cached(key_prefix="biller_stats", expire=300)
async def get_biller_stats(db: AsyncSession = Depends(get_db)):
    """
    Get biller statistics (optimized aggregation queries).

    Performance: Uses COUNT aggregations with indexes.
    """
    logger.info("Fetching biller statistics")

    # Total billers
    total_query = select(func.count(Biller.blr_id))
    total_result = await db.execute(total_query)
    total = total_result.scalar()

    # Billers by category
    category_query = select(
        Biller.blr_category_name, func.count(Biller.blr_id).label("count")
    ).group_by(Biller.blr_category_name).order_by(func.count(Biller.blr_id).desc())

    category_result = await db.execute(category_query)
    categories = category_result.all()

    return {
        "total_billers": total,
        "by_category": [{"category": cat, "count": count} for cat, count in categories],
    }
